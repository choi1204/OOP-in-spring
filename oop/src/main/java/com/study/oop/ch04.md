# 자바가 확장한 객체 지향
객체 지향 4대 특성을 넘어 자바가 객체 지향을 확장하기 위한 키워드와 개념을 공부하자.

<h2> abstract - 추상 메서드와 추상 클래스 </h2>

- 추상 메서드 : 구현부가 없는 메서드
- 추상 메서드를 1개 이상 가진 클래스는 무조건 추상 클래스로 선언해야한다.
- 추상메서드가 없어도 추상클래스 선언이 가능하다.
- 추상클래스는 인스턴스를 만들 수 없다.
- 추상클래스는 하위 클래스에게 메서드의 구현을 강제한다.

<h3> 추상클래스가 필요한 이유 </h3>
동일한 함수로 하위 클래스들이 각자 다른 행위를 할때 메서드 구현을 강제화하기 위해서.

<h2> 생성자 </h2>

``
객체를 생성하는 메서드. 클래스명과 같은 이름을 가진다.
객체 생성자 메서드라 한다.
``

- 개발자가 생성자를 만들지 않으면 자바는 인자 없는 기본 생성자를 만든다.
- 인자가 있는 생성자를 만든다면 자바는 기본 생성자를 자동으로 만들어주지 않는다.

<h2> 클래스 생성 시의 실행 블록, static 블록 </h2>

```java
public class 동물 {
    static {
        System.out.println("static 동물");
    }
}
```
- static 블록에서 사용할 수 있는 속성과 메서드는 static 멤버 뿐
- static 블록은 클래스를 최초로 사용할 때 1회만 실행된다.

<b> 클래스가 제일 처음 사용되는 경우 </b>
- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메소드를 사용할 때
-클래스의 인스턴스를 최초로 만들때

``
instance block도 존재한다. 
아무런 표시없이 {}블록을 사용하게 되면 instance block.
``

<h2>final 키워드</h2>
클래스, 변수, 메서드 세군데에서 사용이 가능하다.

<h3>final의 의미</h3>
- 변수 : 변경이 불가능한 상수
- 클래스 : 상속을 허락하지 않는다.
- 메서드 : 오버라이딩 금지.

<h2> instance 연산자 </h2>
만들어진 객체가 특정클래스의 인스턴스인지 물어보는 연산자.

```aidl
객체 참조변수 instance of 클래스명
```
instance of 연산자가 있을경우 LSP를 어기는 코드가 될 확률이 높기에 리팩토링의 대상인지 점검이 필요하다.

<h2> package 키워드 </h2>
네임스페이스를 만들어주는 역할을 한다.
동일한 클래스명이 있을경우 package를 나눠서 관리.

<h2> interface 키워드와 implements 키워드 </h2>
인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다.<br>
자바 8이후부터 default 메서드를 가질 수 있다. <br>
-> 메서드에 public, abstract 속성에 public, static, final을 붙이지 않아도 된다. <br>
-> 그럼에도 붙여서 코드를 명확하게 하는 것을 권장.

<h2>this 키워드</h2>
객체가 자기자신을 지칭할 때 사용하는 키워드.

- 지연변수와 속성의 이름이 같은 경우 지역변수가 우선한다.
- 객체 변수와 이름이 같은 지역변수가 있는 경우 객체변수를 사용하기 위해 this 키워드 사용.
- 정적변수와 이름이 같은 지역변수가 있을경우 클래스명을 접두사로 사용해야 한다.

<h2>super 키워드 </h2>
바로 위 상위 클래스의 인스턴스를 지칭한다.<br>
super.super.method()와 같은 상위의 상위 클래스의 인스턴스에는 접근 불가능.

<h2> 예비 고수를 위한 한마디 </h2>

```java
class 펭귄 {
    void test() {
        System.out.println("Test");
    }
}

public class Driver {
    public static void main(String[] args) {
        펭귄 뽀로로 = new 펭귄();
        뽀로로.test();
    }
}
```
위의 경우를 실제 메모리를 살펴보면 객체 메서드를 사용할때 뽀로로.test()가 아닌 펭귄.test()로 되어있다.<br>
만일 객체가 100개 이상이되서 각각의 객체 메서드를 실행한다면 객체메서드가 100개 이상 생기게 된다.<br>
그래서 JVM은 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나만 가지게 된다. <BR>
그리고 객체 메서드가 호출될때 this키워드를 사용해서 자기자신을 넘기낟.

```java
class 펭귄 {
    static void test(펭귄 this) {
        System.out.println("Test");
    }
}

public class Driver {
    public static void main(String[] args) {
        펭귄 뽀로로 = new 펭귄();
        뽀로로.test(뽀로로);
    }
}
```
와 같은 코드로 자동으로 변경이 된다.
