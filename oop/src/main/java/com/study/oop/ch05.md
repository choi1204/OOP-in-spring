#객체 지향 설계 5원칙 - SOLID
- SRP(Single Responsibility Principle) : 단일 책임 원칙
- OCP(Open Closed Principle) : 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle) : 의존 역전 원칙

응집도는 높이고 결합도는 낮추는 고전 원칙을 객체 지향의 관점에서 재정립한 것.

<h2> SRP - 단일 책임 원칙 </h2>

```aidl
어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
```
<b> SRP 위반 코드</b>

```java
public class 강아지 {
	final static Boolean 숫컷 = true;
	final static Boolean 암컷 = false;
	Boolean 성별;

	void 소변보다() {
		if (this.성별 == 숫컷) {
			// 한쪽 다리를 들고 소변을 본다.
		} else {
			// 뒤다리 두 개로 앉은 자세로 소변을 본다.
		}
	}
}
```

<b> 리팩토링 코드 </b>

```java
public abstract class 강아지 {
	abstract void 소변보다();
}

public class 숫컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

public class 암컷강아지 extends 강아지 {
	void 소변보다() {
		// 뒤다리 두 개로 앉은 자세로 소변을 본다.
	}
}
```
SRP과 가장 관계가 깊은 객체 지향 4대 특성은 '추상화'이다. 

<h2>OCP - 개방 폐쇄 원칙</h2>
```aidl
소프트웨어 엔티티는 확장에 대해서는 열려 있어야 하고 변경에 대해서는 닫혀 있어야 한다.
==
자신의 확장에는 열려 있고 주변의 변화에 대해서는 닫혀 있어야 한다.
```
상위클래스 또는 인터페이스를 중간에 두어서 다양한 종류의 클래스로 변경이 되도 직접적인 영향을 받지 않게 한다.


<b> OCP의 예 </b>

- 스프링 프레임워크
- 자바(소스코드가 어떤 OS에 걱정하지 않는다)
- 자바  JDBC인터페이스 

<h2> LSP - 리스코ㅡ 치환 원칙 </h2>

```aidl
서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있다.
```
<b> 객체 지향 상속의 조건 </b>
- 하위 클래스 is a kind of 상위 클래스 :하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.

만일 상속이 조직도나 계층도 형태로 구축되어 있다면 리스코프 치환 원칙이 적용되지 않은 것 이다.<br>

[위키피디아 리스코프 치환법칙 정리](http://ko.wikipedia.org/wiki/리스코프_치환_원칙)
- 하위형에서 선행 조건은 강화될 수 없다.
- 하위형에서 후행 조건은 약화될 수 없다.
- 하위형에서 상위형의 불변조건은 반드시 유지되어야한다.

<h2>ISP - 인터페이스 분리 원칙</h2>
```aidl
클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.
```
하나의 클래스가 여러가지 역할을 할 경우 각각의 역할을 인터페이스 분리.
- SRP와 ISP는 같은 문제에 대한 두가지 다른 해결책.
- 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.

<B>인터페이스 최소주의 원칙</B>
- 인터페이스를 외부에 제공할 떄는 최소한의 메서드만 제공.
- 인터페이스는 그 역할에 충실한 최소한의 기능만 공개.
- 상위 클래스는 풍성할 수록 적고 인터페이스는 적을 수록 좋다.
    - 빈약한 상위클래스를 사용하면 속성과 메서드가 하위클래스에 중복되는 경우가 많다.
    - 풍성한 상위 클래스에서는 하위 클래스에서 공통으로 가질 속성과 메서드를 상속한다.

<h2>DIP - 의존 역전 법칙</h2>
```aidl
고차원 모듈은 저차원 모듈에 의존하면 안된다.
이때 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
추상화된 것은 구체적인 것에 의존하면 안된다.
구체적인 것이 추상화된 것에 의존해야 한다.
자주 변경되는 구체 클래스에 의존하지 마라.
```

```aidl
자신보다 변하기 쉬운 것에 의존하지 마라.
```
