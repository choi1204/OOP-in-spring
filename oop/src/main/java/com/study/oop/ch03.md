# 자바와 객체 지향

<h2>객체 지향은 인간 지향이다 </h2>
객체 지향을 이해하기 위해서는 먼저 큰그림을 생각해보아야 한다.
<h3> 객체 지향의 큰그림 </h3>
- 세상에 존재하는 모든 것은 사물(객체)이다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

<h2> 객체지향의 4대 특성 </h2>

- 캡슐화 : 정보은닉
- 상속 : 재사용 (상속이라는 표현보다 확장이 정확한 의미)
- 추상화 : 모델링
- 다형성 : 사용 편의

<h2>클래스 vs 객체 != 붕어빵틀 vs 붕어빵 </h2>
흔히 클래스와 객체를 붕어빵틀과 붕어빵이라고 설명한다. <br>
```
붕어빵틀 붕어빵 = new 붕어빵틀();
```
위의 코드를 보면 붕어빵틀을 새로만들엇더니 붕어빵이 나온다.
무언가 논리에 맞지 않는 것을 알 수 있다.<br>

<h3> 클래스와 객체 구별방법 </h3>
그렇다면 어떻게 클래스와 객체를 구별할 수 있을까?
클래스는 분류에 대한 개념이고 객체는 실체이다.
사람은 클래스이고 박지성과 김연아는 객체이다.

```
클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아
```

<h2> 추상화 : 모델링 </h2>

```
객체지향의 추상화는 곧 모델링이다.
```
컴퓨터프로그램을 만드는 과정에서 개발자는 먼저 클래스를 설계해야 한다.<br>
클래스를 설계할때 실세계에 해당하는 모든 특성을 프로그램에 나열했다가는 너무 거대한 프로그램이 되어버린다<br>
그래서 내가 만들려고 하는 애플리케이션에 해당하는 특성들만 구체적으로 설계해야한다.

IT에서 추상화란 구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 
있는 특성만 가지고 재조합하는 것(모델링)이다

<h3>정리</h3>
- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 펭귄:뽀로로
- 클래스 설계에서 추상화가 사용된다.
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야한다.
- 객체 지향에서 추상화의 결과는 클래스다.

<h2>클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버</h2>
정적 속성들은 해당클래스의 모든 객체가 같은 값을 가질 때 사용하는 것이 기본이다. 물론 이외의 경우에도 쓸수 있지만 그때는 정당한 논리를 가지고 써야한다.<br>
정적 속성의 경우에 스태틱 영역에 클래스가 배치될때 클래스 내부에 
메모리 공간이 확보된다. <br>
반면 객체 속성은 속성명만 있지 실제 메모리 공간은 객체가 힙영역에 생성되면 그때 메모리 공간이 할당된다.
<br>
지역변수의 경우 그 영역에서만 사용되어지기에 초기값이 자동으로 설정되지 않고 쓰레기 값을 갖게 된다. 따라서 개발자가 직접 값을 넣어주어야 한다.
반면 공유변수의 성격을 갖는 멤버변수는 프로그램 어디서든 접근할 수 있기에 누군가 초기화를 해야한다고 규정하기 어렵다.
따라서 자동으로 기본값들로 초기화가 되도록 지원한다.<br>

<h2> 상속: 재사용 + 확장 </h2>
객체 지향의 상속은 우리가 일반적으로 아는 부모와 자식간의 상속관계가 아니다. <br>
객체 지향의 상속은 재사용과 확장으로 이해하는 것이 맞다.

<b>상속관계에서 만족해야하는 문장</b>
- 하위 클래스는 상위 클래스다.(리스코프 치환법칙)
- 'is a' 가 아닌 'is a kind of'이다.

<h3> 상속의 강력함 </h3>
- 상속을 통해 최상위 클래스 Object의 특성을 물려받아 toString() 메서드를 모든 서브클래스에서 사용가능하다.
- 구체화된 객체들을 하나의 일반화된 개념으로 사용할 수 있다.

<h3> 다중 상속과 자바 </h3>

- 자바는 다중 상속을 지원하지 않는다.
- 다중 상속을 지원할경우 똑같은 메서드를 상속받을 경우 여러부모중 어떤부모의 메서드를 상속받아야 하는지에 대한 문제(다이아몬드 문제)
가 발생한다. <br>
- 대신 자바는 인터페이스를 도입한다.

<h3> 상속과 인터페이스 </h3>

- 상속 : is a kind of
- 인터페이스 : is able to 

<b> 자바 인터페이스의 예 </b>
- Serializable : 직렬화 할 수 있는
- Cloneable : 복제할 수 있는
- Comparable : 비교할 수 있는
- Runnable : 실행 할 수 있는

상위클래스에서 물려줄 특성이 풍성할 수록, 인터페이스는 구현을 강제할 개수가 적을 수록 좋다.
(리스코프 치환 원칙과 인터페이스 분할 원칙에 따라서 자세한 건 5장에 다룸)

<h2> 다형성: 사용편의성 </h2>
객체 지향에서의 다형성은 오버라이딩 vs 오버로딩이라고 할 수 있다.

- 오버라이딩 : 같은 메서드 이름, 인자로 상위 클래스의 메서드를 재정의
- 오버로딩 : 같은 메서드 이름, 다른 인자로 다수의 메서드를 중복 정의
``
오버로딩이 다형성인지는 이견이 있다.
``

```
Animal pingu = new Penguin();
```
위 코드와 같은 형식으로 사용 가능.
이때 상위 클래스의 객체 참조변수를 상용하더라도 오버라이딩한 메소드를 사용할 경우 하위클래스의 메소드가 실행된다.
<br> 다형성은 개발자의 편의성을 제공해준다.

<h2> 캡슐화: 정보 은닉 </h2>

- public : 모두 접근가능
- protected : 상속 / 같은 패키지 내의 클래스 접근 가능
- default : 같은 패키지 내의 클래스에서 접근 가능
- private : 본인만 접근가능

정적 멤버의 경우 클래스명.정적멤버로 접근하는 것을 권장.

<h2> 참조 변수의 복사 </h2>
- 기본 자료형 변수 복사시 Call by value
- 참조형 변수 복사시에도 값을 복사하는 Call by value(단 참조형 변수의 값이 주소)

간혹 참조형 변수 복사가 call by reference라고 하지만 본질적으로 가지고 있는 값을 복사해서 주는 것이기에 차이가 없다.






