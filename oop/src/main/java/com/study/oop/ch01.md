<h1> 사람을 사랑한 기술</h1>

<h2> 기계어 - 0과 1의 행진</h2>
0,1 로 이루어진 컴퓨터가 이해할 수 있는 언어로 에드삭, 유니박 전용 기계어가 존재했다. <br>
인간이 이해하기에 너무나 low level의 언어

<h2> 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향적 언어 </h2>
기계어의 명령들을 일상 용어(니모닉)로 표현하고 그것을 기계가 기계어로 번역하게 만든 언어. <br>
cpu마다 기계어가 다르기 때문에 cpu별로 각각의 어셈블리어가 생겨나기 시작했다. <br>
-> cpu가 변경되면 어셈블리어를 다시 새로 배워야하는 불편함이 있음 <br>
-> 기계어를 벗어나 인간의 언어를 모방한 프로그래밍의 시작

<h2>C언어 - 강력한 이식성</h2>
어셈블리어에서 생겨난 문제점을 극복한 언어. <br>
- One Source : 하나의 C 소스 파일만 작성
- MultiObject : 기종마다 하나씩 기계어 목적 파일을 생성
- Use Anywhere : 모든 컴퓨터에서 실행가능. 

단 하나의 소스파일로 부터 각 기계에 맞는 컴파일러로 컴파 일 하여 각 기계에 맞는 기계어 목적파일이 생성됨.<br>
-> 운영체제별로 컴파일러의 특징이 다르기 때문에 기종에 맞게 소스를 변경하는 작업이 필요함<br>
-> 즉 One Source뒤에 Fix Source 작업이 실질적으로 필요함 . <br>
-> C언어 부터 기계어와 m:n매칭이 가능해졌다.

<h2> C++ 언어 - 객체지향의 시작 </h2>
C에 객체지향을 도입함으로써 역사에 한 획을 그은 언어가 됐다. <br>
기계어 -> 어셈블리어 -> C언어의 과정을 살펴보면 인간을 위한 과정임을 알 수 있다. <br>
객체지향 역시 인간을 위한 패러다임의 극적 변화이다.

<h2>Java - 진정한 객체지향 언어 </h2>
C++는 객체 없는 프로그래밍이 가능한 반면 자바는 객체 없이 프로그래밍이 불가능하다. <BR>
JVM이라는 가상머신 도입 시작. <br>
C에서는 One Source Multi Object Use AnyWhere을 이상향으로 했다면 자바에서는 Write Once Use Anywhere을 지향했다.<br>
C언어를 실행할때 각 기종별 컴파일러에 소스파일을 맞춰야하는 문제가 있었다면 가상머신을 통해 그 점을 해결하였다. <br>
소스파일을 자바 컴파일러로 컴파일 후 나온 결과인 오브젝트 파일을 각각의 os에서 실행을 시키면
각각의 os에서는 os에 맞는 jre를 설치만 한다면 소스파일의 변경없이 우리가 원하는 코드파일이 
정상적으로 실행이 되었다. <br>
->단 하나의 컴파일러로 소스실행 가능(단 os별 jre설치)



